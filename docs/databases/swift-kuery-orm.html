<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73924704-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-73924704-2', { 'anonymize_ip': true });
    </script>
    <title>Learn - Getting Started</title>
    <link rel="icon" type="image/png" href="../assets/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../assets/favicon-16x16.png" sizes="16x16" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../css/reset.css">
    <link rel="stylesheet" href="../../css/docs.css">
    <link href=“https://fonts.googleapis.com/css?family=IBM+Plex+Sans” rel=“stylesheet”>
  </head>
  <body>
    <h1 class="heading-1">Swift Kuery ORM</h1>
    <p class="block-text">Swift Kuery ORM is an ORM (Object Relational Mapping) library for Swift built on top of <a target="_blank" href="https://github.com/IBM-Swift/Swift-Kuery">Swift Kuery</a> . Using it allows you to simplify persistence of model objects with your server.</p>
    <p class="block-text">This guide uses Swift Kuery ORM with <a onclick="setActiveSidebarElementForParent('codable-routing')" href="../routing/codable-routing.html">Codable routes</a> however the Swift Kuery ORM also works with <a onclick="setActiveSidebarElementForParent('raw-routing')" href="../routing/raw-routing.html#">Raw Routing</a>.</p>
    <h2 class="heading-2">Prerequisites</h2>
    <ul class="plain-list">
      <li><span class="blue-text">Kitura Server:</span> Learn how to create one in our getting started guide</li>
      <li><span class="blue-text">Routing:</span> Learn how to add routes in our routing guides</li>
      <li><a onclick="localStorage.setItem('package', 'Swift-Kuery-ORM'); setActiveSidebarElementForParent('swift-kuery-orm')" href="../getting-started/update-package.html#">Update Dependencies:</a> SwiftKueryORM needs adding to the Package.swift file.</li>
    </ul>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 1:</span> Add Swift Kuery ORM to the project</h2>
    <p>import Swift Kuery ORM to our project:</p>
    <pre><code class="language-swift">import SwiftKueryORM</code></pre>
    <p>To work with the ORM we need to have a Database plugin to use.</p>
    <p>In this example we will be using <a>SwiftKueryPostgreSQL</a>:</p>
    <pre><code class="language-swift">import SwiftKueryPostgreSQL</code></pre>
    <div class="info">
      <p>You can use any database plugin but ensure that it's been added to your Package.swift.</p>
    </div>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 2:</span> Update our Model</h2>
    <p>The key component of Swift Kuery ORM is the Model protocol.</p>
    <p>All we need to do to make use of the Model protocol is create an extension for our Model:</p>
    <pre><code class="language-swift">extension Book: Model { }</code></pre>
    <p>The Model protocol extends what Codable provides to work with the ORM.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 3:</span> Create a database connection</h2>
    <h3 class="heading-3">Install the PostgreSQL client</h3>
    <p>To use Swift-Kuery-PostgreSQL you need to have the appropiate PostgreSQL C-language client installed.</p>
    <h4 class="heading-4">macOS</h4>
    <p>On macOS we can use Homebrew to install Postgres:</p>
    <pre><code class="language-swift">brew install postgresql</code></pre>
    <h4 class="heading-4">Linux</h4>
    <p>On Linux we can use `apt-get` to install Postgres:</p>
    <pre><code class="language-swift">sudo apt-get install libpq-dev</code></pre>
    <h3 class="heading-3">Create a PostgreSQL database</h3>
    <p>Now that we have PostgreSQL installed we can create a database:</p>
    <pre><code class="language-swift">createdb bookdb</code></pre>
    <p>Now we're ready to connect to our database from our Kitura server.</p>
    <h3 class="heading-3">Create a PostgreSQL connection pool</h3>
    <p>Next we create an instance of a PostgreSQL connection:</p>
    <pre><code class="language-swift">let pool = PostgreSQLConnection.createPool(host: "localhost", port: 5432, options: [.databaseName("bookdb")], poolOptions: ConnectionPoolOptions(initialCapacity: 10, maxCapacity: 50))
Database.default = Database(pool)</code></pre>
    <h3 class="heading-3">Create a table in the database</h3>
    <p></p>
    <pre><code class="language-swift">do {
    try Book.createTableSync()
} catch let error {
    Log.error(error.localizedDescription)
}</code></pre>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 4:</span> Save an Object to our database</h2>
    <div class="info">
      <p>We are no longer using a Dictionary to store data. If you followed the Codable routing guide to get here then make sure you remove all the `bookStore` code.</p>
    </div>
    <p>If we want to save a new object to our database we have to use the save() method.</p>
    <p>In our handler for the POST route we can add the following:</p>
    <pre><code class="language-swift">book.save(completion)</code></pre>
    <p>The POST handler should look similar to this:</p>
    <pre><code class="language-swift">func postHandler(book: Book, completion: @escaping (Book?, RequestError?) -> Void) {
    book.save(completion)
    completion(book, nil)
}</code></pre>
    <p>TODO: We also need to add @escaping to our handlers - explain why!</p>
    <p>That's all we need to do. With that line any Book data posted to the `/books` end point will be stored in our database.</p>
    <p>All we need to do now is be able to retrieve data from our database.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 5:</span> Retrieve an Object from your database</h2>
    <p>If we want to retrieve all the Book data from our database we use the `findAll` method.</p>
    <p>This will return an array containing the all the books.</p>
    <p>In our handler for getting all the books we can add the following:</p>
    <pre><code class="language-swift">Book.findAll { books, error in
  guard let books = books else {
    completion(nil, .internalServerError)
    return
  }
  completion(books, nil)
}</code></pre>
    <p>The GET handler should look similar to this:</p>
    <pre><code class="language-swift">func getAllHandler(completion: @escaping ([Book]?, RequestError?) -> Void) {
  Book.findAll { books, error in
    guard let books = books else {
      completion(nil, .internalServerError)
      return
    }
    completion(books, nil)
  }
}</code></pre>
    <p>We've added some error handling here as well. We check to ensure we got something back, otherwise there's an error with the server.</p>
    <p>Even an empty Array is a valid response.</p>
    <p>Now we can test our Database using cURL to ensure everything is working correctly.</p>
    <div class="info">
      <p>Kitura has support for OpenAPI which makes testing Codable routes easy and provides a UI for testing.</p>
      <p>You can add OpenAPI to your server using our OpenAPI guide.</p>
    </div>
    <p>Firstly we need to start our Kitura server</p>
    <p>Then in a terminal:</p>
    <pre><code>curl -X POST \
  http://localhost:8080/books \
  -H 'content-type: application/json' \
  -d '{
    "id": 0,
    "title": "A Game of Thrones",
    "price": 14.99,
    "genre": Fantasy
}'</code></pre>
    <p>You should see the following:</p>
    <pre><code>{"id": 0,"title":"A Game of Thrones","price":14.99,"genre":"Fantasy"}%</code></pre>
    <p>Next we can retrieve the data back.</p>
    <p>In a terminal:</p>
    <pre><code class="language-swift">curl -X GET \
  http://localhost:8080/books \
  -H 'content-type: application/json'</code></pre>
    <p>Again you should see the following:</p>
    <pre><code>[{"id": 0,"title":"A Game of Thrones","price":14.99,"genre":"Fantasy"}]%</code></pre>
    <p>If we stop the server, and then restart it and run the following in a terminal again:</p>
    <pre><code>curl -X GET \
  http://localhost:8080/books \
  -H 'content-type: application/json'</code></pre>
    <p>You should still see the following output:</p>
    <pre><code>[{"id": 0,"title":"A Game of Thrones","price":14.99,"genre":"Fantasy"}]%</code></pre>
    <p>Our data has persisted even though our server has been stopped. This is one of the many perks of using a database.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 6:</span> Retrieve an Object from your database using Query Parameters</h2>
    <div class="info">
      <p>This section assumes you have Query Parameters already integrated with your Codable routes.</p>
      <p>If you do not, you can learn how to do this in our Codable routing with Query Parameters section.</p>
    </div>
    <p>We first need to modify our `getSingleQuery` function, so lets start by removing all the code here so we end up with:</p>
    <pre><code class="language-swift">func getSingleQuery(query: BookQuery, completion: (Book?, RequestError?) -> Void) {
}</code></pre>
    <p>Now we can use the `findAll(matching: QueryParams)` method provided by the ORM passing in our query:</p>
    <pre><code class="language-swift">func getSingleQuery(query: BookQuery, completion: @escaping  (Book?, RequestError?) -> Void) {
  Book.findAll(matching: query) { books, error in
    if let error = error {
      Log.error(error.localizedDescription)
    }
    if let books = books {
      if books.count != 0 {
        completion(books[0], nil)
      } else {
        completion(nil, RequestError.notFound)
      }
    }
  }
}</code></pre>
    <p>Once we have a result from the database following our request, we first check to ensure there were no errors.</p>
    <p>Once we've confirmed we are error free we can ensure we actually got a value back.</p>
    <p>Then we can pass the value through to the completion handler.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 7:</span> Retrieve Objects from your database using Query Parameters filters</h2>
    <p>Query Parameters provide several filter methods that we can make use of, such as:</p>
    <ul>
      <li>GreaterThan</li>
      <li>LowerThan</li>
      <li>InclusiveRange</li>
      <li>Ordering</li>
      <li>Pagination</li>
    </ul>
    <p>plus many others.</p>
    <p>To use these methods we need to modify our QueryParams type:</p>
    <pre><code class="language-swift">public struct PriceQuery: QueryParams {
  let price: InclusiveRange<Double>?
}</code></pre>
    <div class="info">
      <p>The property name in your QueryParams model must correspond to a matching property name in your Codable model.</p>
      <p>In the example above the InclusiveRange filter is being applied to the `price` property of Book, therefore the property name in the QueryParams model must also be price.</p>
    </div>
    <div class="underline"></div>
    <h2 class="heading-2">Next steps</h2>
    <p><span class="blue-text bold"><a onclick="setActiveSidebarElementForParent('kitura-session')" href="../sessions/kitura-session.html#">Add Kitura Sessions:</a></span> Get useful feedback from your server about startup and errors</p>
    <script type="text/javascript" src="../../scripts/docs.js"></script>
    <script type="text/javascript" src="../../scripts/prism.js"></script>
  </body>
</html>
