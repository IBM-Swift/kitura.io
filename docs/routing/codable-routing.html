<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73924704-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-73924704-2', { 'anonymize_ip': true });
    </script>
    <title>Learn - Getting Started</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../css/reset.css">
    <link rel="stylesheet" href="../../css/docs.css">
    <link href=“https://fonts.googleapis.com/css?family=IBM+Plex+Sans” rel=“stylesheet”>
  </head>
  <body>
    <h1>Codable Routing</h1>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
    <h2>Prerequisites</h2>
    <ul class="plain-list">
      <li><span class="blue-text">Kitura Server:</span> Learn how to create one in our Getting Started guide</li>
    </ul>
    <div class="info">
      <p> We also highly recommend you have logging enabled on your server.</p>
      <p>You can learn how to add logging in our Logging guide.</p>
      <p>The code examples will assume you have logging enabled.</p>
    </div>
    <p>In this guide the project name we will be using is `MyKituraApp`.</p>
    <p>So if you've ended up here from the Getting Started or Logging sections all commands should be accurate.</p>
    <p>For everyone else, just replace all instances of `MyKituraApp` with the name of your own project.</p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 1:</span> Create a POST Codable Route</h2>
    <div class="info">
      <p>If you created your project using Kitura CLI or the Kitura macOS app then your project structure may be different.</p>
      <p>The file you will be working with is:</p>
      <pre>/Sources/Application/Application.swift</pre>
    </div>
    <p>Open your main.swift file:</p>
    <pre>open Sources/MyKituraApp/main.swift</pre>
    <p>Below the line `let router = Router()` add:</p>
    <pre>router.post("/books", handler: postHandler)</pre>
    <p>What we've done is register a POST on our router that will handle any POST requests made on "/books".</p>
    <p>The handling is defined by the handler parameter. Which is a block of code that will be executed in reponse to the request.</p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 2:</span> Define the Handler</h2>
    <p>If we try to build the project now it will fail to compile.</p>
    <p>This is because the `postHandler` hasn't been defined.</p>
    <p>The postHandler is a block of code, called a closure, that is executed when a POST request is made to "/books".</p>
    <p>Add the following code above the `router.post(...)` line:</p>
    <pre>func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
  completion(book, nil)
}</pre>
    <p>The result should look similar to this:</p>
    <pre>import Kitura
import LoggerAPI
import HeliumLogger

HeliumLogger.use()

let router = Router()

func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
    completion(book, nil)
}

router.post("/books", handler: postHandler)

Kitura.addHTTPServer(onPort: 8080, with: router)
Kitura.run()</pre>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 3:</span> Create the data model</h2>
    <p>If we try to compile the code now it will still fail, but this time for a different reason.</p>
    <p>In our postHandler we have a completion parameter that accepts a tuple of type:</p>
    <pre>(Book?, RequestError?)</pre>
    <p>Book is a custom Swift type that we haven't defined yet. So lets go ahead and define it.</p>
    <p>Below the line `let router = Router()` add:</p>
    <pre>struct Book: Codable {
  let name: String
  let age: Int
  let active: Bool
}</pre>
    <p>Your code should look similar to this:</p>
    <pre>import Kitura
import LoggerAPI
import HeliumLogger

HeliumLogger.use()

let router = Router()

struct Book: Codable {
    let name: String
    let age: Int
    let active: Bool
}

func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
    completion(book, nil)
}

router.post("/books", handler: postHandler)

Kitura.addHTTPServer(onPort: 8080, with: router)
Kitura.run()</pre>
    <p>Simply put, `Book` is a struct that conforms to Codable.</p>
    <p>Codable is a Swift protocol that provides Encoders and Decoders to convert to and from JSON.</p>
    <p>We can now successfully compile the project!</p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 4:</span> Test the POST route</h2>
    <div class="info">
      <p>Kitura has support for OpenAPI which makes testing Codable routes easy and provides a UI for testing.</p>
      <p>You can add OpenAPI to your server using our OpenAPI guide.</p>
    </div>
    <p>With the project now compiling we can start the server.</p>
    <p>Once the server is running open a terminal window and enter the following:</p>
    <pre>curl -X POST \
  http://localhost:8080/books \
  -H 'content-type: application/json' \
  -d '{
    "name": "Sarah",
    "age": 32,
    "active": true
}'</pre>
    <p>We can use the cURL command to send a request to our server.</p>
    <p>If your Codable route was created correctly you should see the following:</p>
    <pre>{"name":"Sarah","age":32,"active":true}%</pre>
    <p>We have just posted data, now we need to be able to retrieve the data.</p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 5:</span> Create a GET Codable Route</h2>
    <p>We register a GET route in a similar way to the POST route.</p>
    <p>Below the line `router.post("/books", handler: postHandler)` add:</p>
    <pre>router.get("/books", handler: getAllHandler)</pre>
    <p>Just like before we now need to define the handler.</p>
    <p>Below the `postHandler` function add:</p>
    <pre>func getAllHandler(completion: ([Book]?, RequestError?) -> Void) {
  completion(nil, nil)
}</pre>
    <p>You may have noticed that the completion here is expecting an array of books.</p>
    <p>That is because we're defining a route that will retrieve all of the books stored on the server.</p>
    <p>To be able to retrieve data from the server we first need a way to store the data that's sent to it.</p>
    <p>A simple way to do this is using a Dictionary.</p>
    <p>Just above our `postHandler` function add:</p>
    <pre>var bookstore: [String: Book] = [:]</pre>
    <div class="info">
      <p>It's worth noting using a Dictionary not good practice. The better solution would be to create a Database to store the data.</p>
      <p>You can learn how to do this in our Database guide.</p>
    </div>
    <p>Now that we have a way to store our books we need to update our `getAllHandler`:</p>
    <pre>func getAllHandler(completion: ([Book]?, RequestError?) -> Void) {
  let books = bookstore.map({ $0.value })
  completion(books, nil)
}</pre>
    <p>The result of all the changes should look something like this:</p>
    <pre>import Kitura
import LoggerAPI
import HeliumLogger

HeliumLogger.use()

let router = Router()

struct Book: Codable {
    let name: String
    let age: Int
    let active: Bool
}

var bookstore: [String: Book] = [:]

func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
    completion(book, nil)
}

func getAllHandler(completion: ([Book]?, RequestError?) -> Void) {
    let books = bookstore.map({ $0.value })
    completion(books, nil)
}

router.post("/books", handler: postHandler)
router.get("/books", handler: getAllHandler)

Kitura.addHTTPServer(onPort: 8080, with: router)
Kitura.run()</pre>
    <p>Now we can restart our server to test our new endpoint.</p>
    <p>Once the server is running, run the following command in your terminal:</p>
    <pre>curl -X GET \
  http://localhost:8080/books \
  -H 'content-type: application/json'</pre>
    <p>If everything is working you should see the following output:</p>
    <pre>[]%</pre>
    <p>Which makes sense as we haven't stored anything on our server yet.</p>
    <h2><span class="blue-text">Step 6:</span> Store and retrieve data from the server (Optional)</h2>
    <div class="info">
      <p>We will go into greater detail about storing and retrieving data in the Database section.</p>
    </div>
    <p>You can modify the postHandler to store the posted book:</p>
    <pre>func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
  //Add book to the data store
  bookstore[book.name] = book
  completion(book, nil)
}</pre>
    <p>Then resart your server, and run the following in a terminal:</p>
    <pre>curl -X POST \
  http://localhost:8080/books \
  -H 'content-type: application/json' \
  -d '{
    "name": "Sarah",
    "age": 32,
    "active": true
}'</pre>
    <p>Followed by:</p>
    <pre>curl -X GET \
  http://localhost:8080/books \
  -H 'content-type: application/json'</pre>
    <p>You should now see the following output:</p>
    <pre>[{"name":"Sarah","age":32,"active":true}]%</pre>
    <p>Again using Dictionaries isn't a practical way to store your data. Infact it's really not a good idea for an application.</p>
    <p>We use it here simply to demonstrate Codable routing.</p>
    <p>In the Database Guides we will dicuss a better way of storing and retrieving data.</p>
    <div class="underline"></div>
    <!-- <p>Currently this route doe</p>
    <p>It's good practice to keep your data models and code logic separate.</p>
    <p>So first lets create a directory for our Models.</p>

    <p>Before we can get started with creating our routes we need to create our data model.</p>

    <p>We will create a Struct called `Book` and give it three properties.</p>
    <ol class="plain-list">
      <li>Name of type String</li>
      <li>Age of type Int</li>
      <li>Active of type Bool</li>
    </ol>

    <p></p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 2:</span> Create datastore</h2>
    <p>To begin implementing RestAPI you need a way to store the data.</p>
    <p>A simple way to do this is to create a Dictionary:</p>

    <div class="underline"></div>
    <h2><span class="blue-text">Step 3:</span> Create the Endpoints</h2>
    <h3>POST</h3>
    <p>Register the POST route</p>
    <pre>router.post("/books", handler: postHandler)</pre>
    <p>TODO: Brief explanation of code?</p>
    <p>Define the postHandler function</p>
    <pre>
      func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
        //Add book to the data store
        bookstore[book.name] = book
        completion(book, nil)
      }</pre>
    <h3>GET</h3>
    <h4>Get All</h4>
    <p>Register the GET route</p>
    <pre>router.get("/books", handler: getAllHandler)</pre>
    <p>TODO: Brief explanation of code?</p>
    <p>Define the getAllHandler function</p>
    <pre>
      func getAllHandler(completion: ([Book]?, RequestError?) -> Void) {
        let books = bookstore.map({ $0.value })
        completion(books, nil)
      }</pre>
    <h4>Get Single</h4>
    <p>Register the GET route</p>
    <pre>router.get("/books", handler: getSingleHandler)</pre>
    <p>TODO: Brief explanation of code?</p>
    <p>Define the getSingleHandler function</p>
    <pre>
      func getSingleHandler(id: Int, completion: (Book?, RequestError?) -> Void) {
        //Some logic
        completion(book, nil)
      }</pre>
    <h3>DELETE</h3>
    <h4>Delete All</h4>
    <p>Register the delete route</p>
    <pre>router.delete("/books", handler: deleteAllHandler)</pre>
    p>TODO: Brief explanation of code?</p>
    <p>Define the deleteAllHandler function</p>
    <pre>
      func deleteAllHandler(completion: (RequestError?) -> Void) {
        bookstore = [:]
        completion(nil)
      }</pre>
    <h4>Delete Single</h4>
    <p>Register the delete route</p>
    <pre>router.delete("/books", handler: deleteSingleHandler)</pre>
    <p>TODO: Brief explanation of code?</p>
    <p>Define the deleteSingleHandler function</p>
    <pre>
      func deleteSingleHandler(id: Int, completion: (RequestError?) -> Void) {
        //Some Logic
        completion(nil)
      }</pre>
    <h3>PUT</h3>
    <p>Register the put route</p>
    <pre>router.put("/books", handler: putHandler)</pre>
    <p>TODO: Brief explanation of code?</p>
    <p>Define the putHandler function</p>
    <pre>
      func putHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
        //Some Logic
        completion(book, nil)
      }</pre>
    <h3>PATCH</h3>
    <p>Register the PATCH route</p>
    <pre>router.patch("/books", handler: patchHandler)</pre>
    <p>TODO: Brief explanation of code?</p>
    <p>Define the patchHandler function</p>
    <pre>
      func patchHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
        //Some Logic
        completion(book, nil)
      }</pre>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 4:</span> Test the Endpoints</h2> -->
    <h2>Next steps</h2>
    <p><span class="blue-text bold"><a onclick="setActiveSidebarElementForParent('open-api')" href="open-api.html">Add Kitura OpenAPI:</a></span> Provides a UI for viewing information about Codable routes.</p>
    <!-- <p><span class="blue-text bold">Add Sessions:</span> Some blurb about Sessions</p>
    <p><span class="blue-text bold">Add Authentication:</span> Some blurb about Authentication</p> -->
    <script type="text/javascript" src="../../scripts/docs.js"></script>
  </body>
</html>
