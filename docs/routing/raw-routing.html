<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73924704-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-73924704-2', { 'anonymize_ip': true });
    </script>
    <title>Learn - Raw Routing</title>
    <link rel="icon" type="image/png" href="../assets/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../assets/favicon-16x16.png" sizes="16x16" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../css/reset.css">
    <link rel="stylesheet" href="../../css/docs.css">
    <link href=“https://fonts.googleapis.com/css?family=IBM+Plex+Sans” rel=“stylesheet”>
  </head>
  <body>
    <h1>Raw Routing</h1>
    <p class="block-text">Raw routing is based on <a target="_blank" href="https://expressjs.com/">express</a> where the route handlers are called with RouterRequest and RouterResponse objects with which to handle the client request and build the response, along with a next completion handler.</p>
    <p class="block-text">Raw routing provides great flexibility and control, but requires you to understand the structure of requests, how to interpret HTTP request headers correctly, how to verify data, and to manually carry out things like JSON parsing.</p>
    <div class="underline"></div>
    <h2>Contents:</h2>
    <ol class="plain-list">
      <h3><li><a href="#prereq">Prerequisites</a></li></h3>
      <p>This section will inform you of the minimum you need to have setup to follow this guide.</p>
      <h3><li><a href="#post">Create a basic POST route</a></li></h3>
      <p>Learn how to send data to a Kitura server using Codable types.</p>
      <h3><li><a href="#getall">Create a basic GET ALL route</a></li></h3>
      <p>Learn how to retrieve all data from a Kitura server.</p>
      <h3><li><a href="#step3">Create a basic GET SINGLE route</a></li></h3>
      <p>Learn how to get a single value from a Kitura server.</p>
    </ol>
    <div class="underline"></div>
    <h2 id="prereq">Prerequisites</h2>
    <ul class="plain-list">
      <li><span class="blue-text">Kitura Server:</span> Learn how to create one in our Getting Started guide</li>
      <li>Your project is set up as described by our style guide.</p>
      <li>You have defined a `Book` struct as described in the Codable routing section of "What is routing?"</li>
    </ul>
    <div class="underline"></div>
    <h2 id="post"><span class="blue-text">Step 1:</span> Create an in memory bookstore</h2>
    <p>If you have already completed Raw routing, you can skip this step</p>
    <p>Since our route handlers are asynchronous, we will use dispatch to serialize access to our bookstore.
        This will prevent collisions from multiple threads trying to access the same array.
         To be able to use `DispatchQueue` on Linux, add the following statement to the start of the file:</p>
    <pre><code class="language-swift">import Dispatch</code></pre>
    <p> Inside the `App` class, below `let router = Router()` add: </p>
    <pre><code class="language-swift">var bookStore: [Book] = []
let workerQueue = DispatchQueue(label: "worker")</code></pre>
    <p>At the end of the app class, add a helper function for atomically executing code:</p>
    <pre><code class="language-swift">func execute(_ block: (() -> Void)) {
   workerQueue.sync {
       block()
   }
}</code></pre>
    <div class="underline"></div>
    <h2 id="post"><span class="blue-text">Step 2:</span> Create a RawRoutes.swift file</h2>
    <p>Open your `Sources` > `Application` > `Application.swift`</p>
    <p> Inside the `postInit()` function add: </p>
    <pre><code class="language-swift">initializeRawRoutes(app: self)</code></pre>
    <p>Create a new file called `RawRoutes.swift` in `Sources` > `Application` > `Routes`</p>
    <p>Inside this file, add the framework for our routes code:</p>
    <pre><code class="language-swift"></code>func initializeRawRoutes(app: App) {
    // Register routes with handlers here
}
    </pre>
    <h2 id="post"><span class="blue-text">Step 3:</span> Create a POST route</h2>
    <p>Inside the `initializeRawRoutes` function add:</p>
    <pre><code class="language-swift">router.post("/raw") { request, response, next in
    next()
}</code></pre>
    <p>What we've done is register a POST on our router that will handle any POST requests made on "/books".</p>
    <div class="info">
      <p>If the values `request`, `response` and `next` are unfamiliar to you then you can learn more about them in our What is Routing? guide.</p>
    </div>
    <p>Our POST route will be used to send information about our books to the server and therefore we need a way of reading this data.</p>
    <p>To do this we can use the `read(as:)` method of the RouterRequest class:</p>
    <pre><code class="language-swift">do {
    let book = try request.read(as: Book.self)
} catch {
    response.send(status: .badRequest)
}</code></pre>
    <p>The `read(as:)` method can throw so we need to wrap it in a do-catch block.</p>
    <p>We will now save this book to our bookStore and return it to the user with `send()`:</p>
    <pre><code class="language-swift">app.execute {
    app.bookStore.append(book)
}
response.send(book)
</code></pre>
    <p>Your completed Post route should now look as follows:</p>
    <pre><code class="language-swift">app.router.post("/raw") { request, response, next in
    do {
        let book = try request.read(as: Book.self)
        app.execute {
            app.bookStore.append(book)
        }
        response.send(book)
    } catch {
        let _ = response.send(status: .badRequest)
    }
    next()
}</code></pre>
    <p>Now if we start our Kitura server we can use curl to test our route.</p>
    <p>In a terminal enter the following:</p>
    <pre><code>curl -X POST \
  http://localhost:8080/raw \
  -H 'content-type: application/json' \
  -d '{
  "id": 0,
  "title": "A Game of Thrones",
  "price": 14.99,
  "genre": "Fantasy"
}'</code></pre>
    <p>We should then see the following printed to the terminal:</p>
    <pre><code>{"id":0,"title":"A Game of Thrones","price":14.99,"genre":"Fantasy"}%</code></pre>
    <p>That's it! We've implemented a basic POST route.</p>
    <div class="underline"></div>
    <h2 id="getall"><span class="blue-text">Step 4:</span> Create a GET route</h2>
    <p>We register a GET route in a similar way to the POST route.</p>
    <p>Inside the `initializeRawRoutes` function add:</p>
    <pre><code class="language-swift">app.router.get("/raw") { request, response, next in
    next()
}</code></pre>
    <p>In our GET route, we respond with our bookstore.</p>
<pre><code class="language-swift">app.execute {
    response.send(app.bookStore)
}</code></pre>
<p>Your completed GET route, should then look as follows:</p>
<pre><code class="language-swift">app.router.get("/raw") { request, response, next in
    app.execute {
        response.send(app.bookStore)
    }
    next()
}</code></pre>
    <p>Now if we need to restart our server and post a book using the Curl command from earlier.</p>
    <p>Then if we open: <a href="http://localhost:8080/raw">http://localhost:8080/raw</a></p>
    <p>We should see the book we posted:</p>
    <pre><code class="language-swift">{
    "id": 0,
    "title": "A Game of Thrones",
    "price": 14.99,
    "genre": "Fantasy"
  }</code></pre>
    <p>That's it! We've now also implemented a simple GET route.</p>
    <h2 id="getall"><span class="blue-text">Step 5:</span> Create a GET one route</h2>
    <p>When register a GET one route, we use an id parameter.</p>
    <p>Inside the `initializeRawRoutes` function add:</p>
    <pre><code class="language-swift">router.get("/raw/:id") { request, response, next in
    next()
}</code></pre>
    <p>In this case, the path /:id will be for /123 as well as /abc.
        You can then access the id parameter’s value via req.parameters["id"]</p>
    <pre><code class="language-swift">app.execute {
    guard let idString = request.parameters["id"],
        let id = Int(idString),
        id >= 0,
        id < app.bookStore.count
    else {
        let _ = response.send(status: .badRequest)
        return next()
    }
    response.send(app.bookStore[id])
}</code></pre>
<p>Your completed GET with id route, should then look as follows:</p>
<pre><code class="language-swift">app.router.get("/raw/:id") { request, response, next in
    app.execute {
        guard let idString = request.parameters["id"],
            let id = Int(idString),
            id >= 0,
            id < app.bookStore.count
        else {
            let _ = response.send(status: .badRequest)
            return next()
        }
        response.send(app.bookStore[id])
    }
    next()
}</code></pre>
    <p>Now if we need to restart our server.</p>
    <p>Make a post request using the Curl command from above.</p>
    <p>Then use a browser to go to <a href="http://localhost:8080/codable/0" target="_blank">localhost:8080/codable/0</a></p>
    <p>This will make a get request to the server and you should see the first book in JSON format:</p>
    <pre><code class="language-swift">{
      "id": 0,
      "title": "A Game of Thrones",
      "price": 14.99,
      "genre": "Fantasy"
  }</code></pre>
  <p>Post a second book to the server. With Curl this would be:</p>
  <pre><code>curl -X POST \
    http://localhost:8080/codable \
    -H 'content-type: application/json' \
    -d '{
      "id": 0,
      "title": "Harry Potter",
      "price": 10.00,
      "genre": "Fantasy"
    }'</code></pre>
    <p>Then open your browser at:</p>
    <p><a href="http://localhost:8080/codable/1" target="_blank">localhost:8080/codable/1</a></p>
    <p>This will make a new get request to the server and you should see the second book in JSON format:</p>
    <p>That's it! We've now also implemented a GET one route.</p>
    <p>We can continue to make POST and GET requests from our bookstore.</p>
    <p>However if the server is restarted, all data will be lost and we'd have an empty array again.</p>
    <p>In the Database Guide we will look to resolve this issue and add persistence.</p>
    <div class="underline"></div>
    <h2>Next steps</h2>
    <p><span class="blue-text bold">Add logging:</span> Get useful feedback from your server about startup and errors</p>
    <p><span class="blue-text bold">Add routing:</span> Add REST APIs, such as HTTP GET, to your server</p>
    <script type="text/javascript" src="../../scripts/prism.js"></script>
    <script type="text/javascript" src="../../scripts/docs.js"></script>
  </body>
</html>
