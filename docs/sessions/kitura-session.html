<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73924704-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-73924704-2', { 'anonymize_ip': true });
    </script>
    <title>Learn - Getting Started</title>
    <link rel="icon" type="image/png" href="../assets/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../assets/favicon-16x16.png" sizes="16x16" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../css/reset.css">
    <link rel="stylesheet" href="../../css/docs.css">
    <link href=“https://fonts.googleapis.com/css?family=IBM+Plex+Sans” rel=“stylesheet”>
  </head>
  <body>
    <h1>Kitura Session</h1>
    <p class="block-text">HTTP is a stateless connection protocol, that is the server can't distinguish one request from another. Sessions and cookies provide HTTP with state, they allow the server to know who is making a specific request and respond accordingly.</p>
    <p class="block-text">This guide uses Kitura Session with Codable routing leveraging type-safe sessions.</p>
    <h2>Prerequisites</h2>
    <ul class="plain-list">
      <li><span class="blue-text">Kitura Server:</span> Learn how to create one in our Getting Started guide</li>
      <li><span class="blue-text">Codable Model:</span> Learn how to create one in our Codable Routing guide</li>
      <li><span class="blue-text">Kitura OpenAPI:</span> Learn how to add this in our Kitura OpenAPI guide</li>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 1:</span> Define a Type-Safe Session</h2>
    <p>First we need to import the KituraSession package:</p>
    <pre><code class="language-swift">import KituraSession</code></pre>
    <p>Next we can declare a type that conforms to the TypeSafeSession protocol.</p>
    <p>We can use either a Class or a Struct here but we will use a Class.</p>
    <p>Underneath our Codable model we add the following:</p>
    <pre><code class="language-swift">// Defines the session instance data
final class CheckoutSession: TypeSafeSession {

    let sessionId: String                       // Requirement: every session must have an ID
    var books: [Book]                           // User-defined type, where Book conforms to Codable

    init(sessionId: String) {                   // Requirement: must be able to create a new (empty)
        self.sessionId = sessionId              // session containing just an ID. Assign a default or
        books = []                              // empty value for any non-optional properties.
    }
}

// Defines the configuration of the user's type: how the cookie is constructed, and how the session is
// persisted.
extension MySession {
    static let sessionCookie: SessionCookie = SessionCookie(name: "MySession", secret: "Top Secret")
    static var store: Store?
} </code></pre>
    <div class="info">
      <p>When using a Class you need to declare it as final.</p>
    </div>
    <p>The minimum requirements for a type-safe session are:</p>
    <ul>
      <li><span class="blue-text">sessionID:</span></li>
      <li><span class="blue-text">Initiliser:</span> Used to create a new sessionId</li>
      <li><span class="blue-text">sessionCookie:</span> Defines the name of the cookie and the secret data used to encrypt it</li>
      <li><span class="blue-text">An optional store:</span> Defines how sessions should be persisted</li>
    </ul>
    <!-- <p>NOTE: If `store` is not defined then a default in-memory store is used.</p>
    <p>NOTE: If your session is a Class it must be declared as final. TODO: Why?</p>
    <p>NOTE: If you define MySession as a struct, then in order to modify it within a handler, you will first need to assign it to a local variable:</p>
    <pre><code class="language-swift">
router.post("/cart") { (session: MySessionStruct, book: Book, respondWith: (Book?, RequestError) -> Void) -> Void in
    var session = session                // Required when mutating a Struct
    session.books.append(book)
    session.save()
    respondWith(book, nil)
}
    </code></pre> -->
    <p>If store isn't specified then a default in memory store is used.</p>
    <p>For an example of a persistent store for sessions see Kitura-Session-Redis</p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 2:</span> Add session POST route</h2>
    <p>At the bottom of the list of the rest of our routes add the following:</p>
    <pre><code class="language-swift">router.post("/cart", handler: postSessionHandler)</code></pre>
    <p>Then below our `handlers` section add the following:</p>
    <pre><code class="language-swift">func postSessionHandler(session: CheckoutSession, book: Book, completion: (Book?, RequestError?) -> Void) -> Void {
    session.books.append(book)
    session.save()
    completion(book, nil)
}</code></pre>
    <p>What we're doing here is storing the posted Book into the session.</p>
    <p>We use the `append` method as we know `books` is an Array as we defined it as an Array in the CheckoutSession class.</p>
    <p>Then we need to save the session.</p>
    <p>Now we can add a route for retrieving the data.</p>
    <h2><span class="blue-text">Step 3:</span> Add session GET route</h2>
    <p>Just below the POST route we just added we can add the following:</p>
    <pre><code class="language-swift">router.get("/cart", handler: getSessionHandler)</code></pre>
    <p>Then again below our postSessionHandler handler we can add:</p>
    <pre><code class="language-swift">func getSessionHandler(session: UserSession, completion: ([User]?, RequestError?) -> Void) -> Void {
    completion(session.users, nil)
}</code></pre>
    <p>Add that's it. We've now enabled a Kitura Session on our server.</p>
    <p>We can now test to enusre this works, and the easiest way to do that is using Kitura OpenAPI</p>
    <div class="underline"></div>
    <h2><span class="blue-text">Step 4:</span> Test our Session</h2>
    <div class="underline"></div>
    <!-- <h2>Step 3: Saving/Terminating a session</h2>
    <h2>TODO: Does this need to be it's own step?</h2>
    <p>You need to save the session when a change is made to the session.</p>
    <p>A change could look something like this:</p>
    <pre><code class="language-swift">
router.post("/cart") { (session: MySession, book: Book, respondWith: (Book?, RequestError) -> Void) -> Void in
    session.books.append(book)
    ...
}   </code></pre>
    <p>Where during a HTTP POST you need to store some data.</p>
    <p>Saving the session:</p>
    <pre><code class="language-swift">session.save()</code></pre>
    <p>When you want to remove a session from the store it can be done as follows:</p>
    <pre><code class="language-swift">session.destroy()</code></pre>
    <div class="underline"></div>
    <h2>Step 4: Handling a store failure</h2>
    <p>During the application's run cycle the store could become inaccessible which will result in a failure to persist or remove sessions.</p>
    <p>In cases like this a server error will be logged to help you understand the issue that has occured</p>
    <p>TODO: Show example of this?</p>
    <p>You can also supply a callback which takes an `Error?`:</p>
    <pre><code class="language-swift">
router.post("/cart") { (session: MySession, book: Book, respondWith: @escaping (Book?, RequestError) -> Void) -> Void in
    session.books.append(book)
    session.save() { error in
        if let error = error {
            respondWith(nil, .internalServerError)
        } else {
            respondWith(book, nil)
        }
    }
}
    </code></pre>
    <div class="underline"></div>
    <h2>Step 5: Enable automatic saving of sessions</h2>
    <p>NOTE: This can only be done if your Session is a class.</p>
    <p>You can define a deinitialiser for the class like so:</p>
    <pre><code class="language-swift">
 deinit {
     self.save()
 }
    </code></pre>
    <p>WARNING: The session will be saved after every request regardless of whether a change has been made</p>
    <p>It's also useful to create a method to check if destroy has been called on the session:</p>
    <pre><code class="language-swift">
  var destroyed: Bool = false {
      didSet { destroy() }
  }

  deinit {
      if !self.destroyed {
          self.save()
      }
  }
    </code></pre>
    <p>Then in your application code rather then calling `session.destroy` you would do:</p>
    <pre><code class="language-swift">session.destroyed = true</code></pre>
    <p>With this you can supress the calling of `save()` during deinitialisation</p>
    <p>Which will prevent the session being persisted back into the store.</p>
    <div class="underline"></div> -->
    <h2>Next steps</h2>
    <p><span class="blue-text bold"><a onclick="setActiveSidebarElementForParent('typesafe-auth')" href="../authentication/typesafe-auth.html#">Add Authentication:</a></span> Get useful feedback from your server about startup and errors</p>
    <script type="text/javascript" src="../../scripts/docs.js"></script>
    <script type="text/javascript" src="../../scripts/prism.js"></script>
  </body>
</html>
